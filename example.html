
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Configurable Web CRT Effect</title>
    <style>
        body {
            margin: 0;
            background-color: #050505;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: monospace;
        }
        #crt-container {
            width: 800px;
            height: 600px;
            box-shadow: 0 0 80px rgba(0, 255, 0, 0.15);
        }
    </style>
</head>
<body>

<div id="crt-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
    uniform sampler2D tDiffuse;
    uniform float time;
    uniform vec2 resolution;

    uniform float curveIntensity;
    uniform float scanlineCount;
    uniform float scanlineIntensity;
    uniform float rgbOffset;
    uniform float vignetteSize;
    uniform float vignetteRoundness;
    uniform float brightnessBoost;
    uniform float noiseStrength;
    uniform float flickerIntensity;

    varying vec2 vUv;

    vec2 curve(vec2 uv) {
        uv = (uv - 0.5) * 2.0;
        vec2 offset = uv.yx / vec2(resolution.x / resolution.y, 1.0);
        uv = uv + uv * offset * offset * curveIntensity;
        return uv * 0.5 + 0.5;
    }

    void main() {
        vec2 q = vUv;
        vec2 uv = curve(q);

        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            return;
        }
        
        // RGB Shift
        float r = texture2D(tDiffuse, uv + vec2(rgbOffset, 0.0)).r;
        float g = texture2D(tDiffuse, uv).g;
        float b = texture2D(tDiffuse, uv + vec2(-rgbOffset, 0.0)).b;
        vec3 color = vec3(r, g, b);
        
        // Scanlines
        float scanline = sin((uv.y * scanlineCount + time * 20.0) * 3.14159 * 2.0);
        float scanlineEffect = 1.0 - scanlineIntensity * (scanline * 0.5 + 0.5); 
        color *= scanlineEffect;
        
        // Vignette
        float dist = distance(uv, vec2(0.5));
        float vignette = smoothstep(vignetteSize + 0.2, vignetteSize - vignetteRoundness, dist);
        color *= vignette;

        // Noise
        float noise = fract(sin(dot(uv * time, vec2(12.9898,78.233))) * 43758.5453);
        color += noise * noiseStrength;

        // Flicker
        color *= 1.0 - flickerIntensity * 0.5 + flickerIntensity * sin(time * 30.0);

        // Brightness
        color *= brightnessBoost;

        gl_FragColor = vec4(color, 1.0);
    }
</script>

<script>
    const container = document.getElementById('crt-container');
    let width = container.clientWidth;
    let height = container.clientHeight;

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 1000);
    camera.position.z = 10;

    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const params = {
        curveIntensity: 0.04,
        scanlineCount: 600.0,
        scanlineIntensity: 0.25,
        rgbOffset: 0.004,
        vignetteSize: 0.25,
        vignetteRoundness: 0.1,
        brightnessBoost: 1.1,
        noiseStrength: 0.03,
        flickerIntensity: 0.03
    };

    const uniforms = {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        resolution: { value: new THREE.Vector2(width, height) },
        curveIntensity: { value: params.curveIntensity },
        scanlineCount: { value: params.scanlineCount },
        scanlineIntensity: { value: params.scanlineIntensity },
        rgbOffset: { value: params.rgbOffset },
        vignetteSize: { value: params.vignetteSize },
        vignetteRoundness: { value: params.vignetteRoundness },
        brightnessBoost: { value: params.brightnessBoost },
        noiseStrength: { value: params.noiseStrength },
        flickerIntensity: { value: params.flickerIntensity }
    };

    const gui = new lil.GUI({ title: 'CRT Settings' });

    gui.add(params, 'curveIntensity', 0.0, 0.2).name('Curvature').onChange(v => uniforms.curveIntensity.value = v);
    gui.add(params, 'scanlineCount', 50.0, 1000.0).name('Scanlines').onChange(v => uniforms.scanlineCount.value = v);
    gui.add(params, 'scanlineIntensity', 0.0, 1.0).name('Scanline Depth').onChange(v => uniforms.scanlineIntensity.value = v);
    gui.add(params, 'rgbOffset', 0.0, 0.02).name('RGB Shift').onChange(v => uniforms.rgbOffset.value = v);
    gui.add(params, 'vignetteSize', 0.0, 1.0).name('Vignette Size').onChange(v => uniforms.vignetteSize.value = v);
    gui.add(params, 'noiseStrength', 0.0, 0.2).name('Static Noise').onChange(v => uniforms.noiseStrength.value = v);
    gui.add(params, 'flickerIntensity', 0.0, 0.2).name('Flicker').onChange(v => uniforms.flickerIntensity.value = v);
    gui.add(params, 'brightnessBoost', 0.5, 2.0).name('Brightness').onChange(v => uniforms.brightnessBoost.value = v);

    const textureLoader = new THREE.TextureLoader();
    const highContrastUrl = 'https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?auto=format&fit=crop&w=1600&q=80';

    textureLoader.load(highContrastUrl, (texture) => {
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        createCRTPlane(texture);
        animate();
    });

    function createCRTPlane(texture) {
        uniforms.tDiffuse.value = texture;
        const geometry = new THREE.PlaneGeometry(width, height);
        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            transparent: true
        });
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);
    }

    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        uniforms.time.value = clock.getElapsedTime();
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        width = container.clientWidth;
        height = container.clientHeight;
        renderer.setSize(width, height);
        uniforms.resolution.value.set(width, height);
        camera.left = width / -2;
        camera.right = width / 2;
        camera.top = height / 2;
        camera.bottom = height / -2;
        camera.updateProjectionMatrix();
    }, false);

</script>
</body>
</html>